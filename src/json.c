/**
 * json.c
 *
 * Written by Gustavo Bacagine <gustavo.bacagine@protonmail.com>
 *
 * Description: Manipulate JSON in C language
 *
 * Date: 2024-02-24
 */

#include "json.h"

static long lGetFileLen(FILE *fpFile)
{
  long lBytes = 0;

  if(fseek(fpFile, 0L, SEEK_END) != 0)
  {
    return -1;
  }

  if((lBytes = ftell(fpFile)) == -1)
  {
    return -2;
  }

  if(fseek(fpFile, 0, SEEK_SET) != 0)
  {
    return -3;
  }

  return lBytes;
}

int iJSON_Read(char **ppszJSON, const char *kpszFileName)
{
  FILE *fpJSON = NULL;
  long lFileLength = 0;

  if(kpszFileName == NULL) return JSON_ERROR;
  
  if((fpJSON = fopen(kpszFileName, "r")) == NULL)
  {
    fprintf(stderr, "%s no such file or directory!", kpszFileName);

    return JSON_ERROR;
  }

  if((lFileLength = lGetFileLen(fpJSON)) < 0)
  {
    fprintf(stderr, "File %s is empty!", kpszFileName);

    return JSON_ERROR;
  }

  *ppszJSON = (char *) malloc(sizeof(char) * lFileLength + 1);

  fread(*ppszJSON, 1, lFileLength, fpJSON);
  (*ppszJSON)[lFileLength] = '\0';

  fclose(fpJSON);
  fpJSON = NULL;

  return JSON_OK;
}

/**
 * Function generated by Chat GPT and modified by
 * Gustavo Bacagine
 *
 * Funcao para encontrar a proxima ocorrencia
 * do caractere especificado na string
 */
static char *pszFindChar(char *pszStr, char chCh)
{
  while(*pszStr != '\0' && *pszStr != chCh)
  {
    pszStr++;
  }
  return (*pszStr == '\0') ? NULL : pszStr;
}

/**
 * Function generated by Chat GPT and modified by
 * Gustavo Bacagine
 *
 * Funcao para extrair um valor de uma chave do JSON
 */
static char *pszExtractValue(const char *kpszJSON, const char *kpszKey)
{
  char *pszKeyStart = NULL;
  char *pszValueStart = NULL;
  char *pszValueEnd = NULL;
  int iValueSize = 0;
  char *pszValue = NULL;

  pszKeyStart = strstr(kpszJSON, kpszKey);

  if (pszKeyStart == NULL) return NULL;

  pszValueStart = pszFindChar(pszKeyStart, ':');

  if (pszValueStart == NULL) return NULL;

  // Avançar para o próximo caractere após ':'
  pszValueStart++;
  while(*pszValueStart == ' ' || *pszValueStart == '"')
  {
    pszValueStart++;
  }

  // Se o valor for uma string, remover as aspas adicionais
  if(*pszValueStart == '"')
  {
    pszValueStart++;
    pszValueEnd = strchr(pszValueStart, '"');
    if (pszValueEnd == NULL) return NULL;
    *pszValueEnd = '\0';
  }

  // Encontrar o fim do valor
  pszValueEnd = pszValueStart;
  while(*pszValueEnd != '\0' &&
         *pszValueEnd != ',' &&
         *pszValueEnd != '}' &&
         *pszValueEnd != '\n' &&
         *pszValueEnd != '"')
  {
    pszValueEnd++;
  }

  // Calcular o tamanho do valor
  iValueSize = pszValueEnd - pszValueStart;

  // Alocar memória para o valor e copiá-lo
  pszValue = (char *) malloc(iValueSize + 1);
  strncpy(pszValue, pszValueStart, iValueSize);
  pszValue[iValueSize] = '\0';

  return pszValue;
}

int iJSON_LoadKeys(const char *kpszJSON, PSTRUCT_JSON *pastJSON)
{
  int ii = 0;

  for(ii = 0; (*pastJSON)[ii].pszKey != NULL; ii++)
  {
    char *pszContent = pszExtractValue(kpszJSON, (*pastJSON)[ii].pszKey);

    switch((*pastJSON)[ii].iKeyType)
    {
      case JSONTYPE_INT:
      {
        *((int *) (*pastJSON)[ii].pData) = atoi(pszContent); // Convert and store integer data
        break;
      }
      case JSONTYPE_STR:
      {
        strncpy((char *) (*pastJSON)[ii].pData, pszContent, (*pastJSON)[ii].iDataSize);
        break;
      }
      default: break;
    }

    free(pszContent);
    pszContent = NULL;
  }

  return JSON_OK;
}

int iJSON_WriteFile(FILE *fpJSON, PSTRUCT_JSON astJSON)
{
  int ii = 0;

  if(fpJSON == NULL || astJSON == NULL) return JSON_ERROR;

  fprintf(fpJSON, "{\n");

  for(ii = 0; astJSON[ii+1].pszKey != NULL; ii++)
  {
    switch(astJSON[ii].iKeyType)
    {
      case JSONTYPE_STR:
      {
        fprintf
        (
          fpJSON,
          "  \"%s\": \"%s\",\n", astJSON[ii].pszKey,
                                 (char *) astJSON[ii].pData
        );
        break;
      }
      case JSONTYPE_INT:
      {
        fprintf
        (
          fpJSON,
          "  \"%s\": %d,\n", astJSON[ii].pszKey,
                             *(int *) astJSON[ii].pData
        );
      }
      default: break;
    }
  }


  switch(astJSON[ii].iKeyType)
  {
    case JSONTYPE_STR:
    {
      fprintf
      (
        fpJSON,
        "  \"%s\": \"%s\"\n", astJSON[ii].pszKey,
                              (char *) astJSON[ii].pData
      );
      break;
    }
    case JSONTYPE_INT:
    {
      fprintf
      (
        fpJSON,
        "  \"%s\": %d\n", astJSON[ii].pszKey,
                          *(int *) astJSON[ii].pData
      );
    }
    default: break;
  }
  fprintf(fpJSON, "}\n");

  return JSON_OK;
}

int iJSON_DumpJSON(char **ppaszJSON, PSTRUCT_JSON astJSON)
{
  int ii = 0;
  int iReallocBuffer = 0;

  if (astJSON == NULL) return JSON_ERROR;

  // Calcula o tamanho necessario para armazenar o conteudo JSON
  iReallocBuffer += snprintf(NULL, 0, "{\n");
  for (ii = 0; astJSON[ii+1].pszKey != NULL; ii++)
  {
    switch(astJSON[ii].iKeyType)
    {
      case JSONTYPE_STR:
      {
        iReallocBuffer += snprintf(NULL, 0,
          "  \"%s\": \"%s\",\n", astJSON[ii].pszKey,
                                (char *) astJSON[ii].pData
        );
        break;
      }
      case JSONTYPE_INT:
      {
        iReallocBuffer += snprintf(NULL, 0,
          "  \"%s\": %d,\n", astJSON[ii].pszKey,
                            *(int *) astJSON[ii].pData
        );
      }
      default: break;
    }
  }

  switch(astJSON[ii].iKeyType)
  {
    case JSONTYPE_STR:
    {
      iReallocBuffer += snprintf(NULL, 0,
        "  \"%s\": \"%s\"\n", astJSON[ii].pszKey,
                              (char *) astJSON[ii].pData
      );
      break;
    }
    case JSONTYPE_INT:
    {
      iReallocBuffer += snprintf(NULL, 0,
        "  \"%s\": %d\n", astJSON[ii].pszKey,
                          *(int *) astJSON[ii].pData
      );
    }
    default: break;
  }
  iReallocBuffer += snprintf(NULL, 0, "}\n");

  // Aloca memoria suficiente para armazenar o conteudo JSON
  *ppaszJSON = realloc(*ppaszJSON, sizeof(char) * (iReallocBuffer + 1)); // +1 para o terminador nulo

  if(*ppaszJSON == NULL) return JSON_ERROR;

  // Preenche a string com o conteudo JSON
  snprintf(*ppaszJSON, iReallocBuffer + 1, "{\n");
  for(ii = 0; astJSON[ii+1].pszKey != NULL; ii++)
  {
    switch (astJSON[ii].iKeyType)
    {
      case JSONTYPE_STR:
      {
        snprintf
        (
          *ppaszJSON + strlen(*ppaszJSON),
          iReallocBuffer + 1,
          "  \"%s\": \"%s\",\n", astJSON[ii].pszKey,
                                (char *) astJSON[ii].pData
        );
        break;
      }
      case JSONTYPE_INT:
      {
        snprintf
        (
          *ppaszJSON + strlen(*ppaszJSON),
          iReallocBuffer + 1,
          "  \"%s\": %d,\n", astJSON[ii].pszKey,
                          *(int *) astJSON[ii].pData
        );
        break;
      }
      default: break;
    }
  }

  switch (astJSON[ii].iKeyType)
  {
    case JSONTYPE_STR:
    {
      snprintf
      (
        *ppaszJSON + strlen(*ppaszJSON),
        iReallocBuffer + 1,
        "  \"%s\": \"%s\"\n", astJSON[ii].pszKey,
                              (char *) astJSON[ii].pData
      );
      break;
    }
    case JSONTYPE_INT:
    {
      snprintf
      (
        *ppaszJSON + strlen(*ppaszJSON),
        iReallocBuffer + 1,
        "  \"%s\": %d\n", astJSON[ii].pszKey,
                        *(int *) astJSON[ii].pData
      );
      break;
    }
    default: break;
  }

  snprintf(*ppaszJSON + strlen(*ppaszJSON), iReallocBuffer + 1, "}\n");

  return JSON_OK;
}
